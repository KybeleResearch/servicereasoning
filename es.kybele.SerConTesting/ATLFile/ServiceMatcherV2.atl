-- @atlcompiler atl2006
-- @nsURI ASD=http://ASD

module ServiceMatcher;
create Contract : ASD from Prov : ASD, Cons : ASD;

helper def: ProvElements : Sequence(ASD!NamedElement) = ASD!NamedElement.allInstancesFrom('Prov');

helper def: ConsElements : Sequence(ASD!NamedElement) = ASD!NamedElement.allInstancesFrom('Cons');

helper def: ServiceDescription : ASD!ServiceDescription = 
	ASD!ServiceDescription.allInstancesFrom('Prov')->first(); 

helper def: Result : String = '';  

-- Return the NamedElement with the same name in the other model
helper context ASD!NamedElement def: getMatchingElementByName(): ASD!NamedElement =
	if (thisModule.ConsElements->includes(self)) then
		thisModule.ProvElements->select(aux | aux.name = self.name)->first()
	else
		thisModule.ConsElements->select(aux | aux.name = self.name)->first()
	endif;

helper context ASD!Operation def: isCompatible(aux: ASD!Operation): String =
	if (aux.messagePattern = self.messagePattern 
		and aux.contents.size() <= self.contents.size())
	then
		'True'
	else
		'False'
	endif;

-- COMPARING MESSAGES ---------------------------
helper context ASD!Message def: isCompatible(aux: ASD!Message): String =
	if (self.subset = aux.subset) and (self.role = aux.role) then
		if (self.subset = #req and self.isSubtypeOf(aux)) or (self.subset = #pro and aux.isSubtypeOf(self)) then
			'True'
		else
			'False'
		endif
	else
		'Unknown'
	endif;

helper context ASD!Message def: isSubtypeOf(aux: ASD!Message): Boolean =
	aux.infoType->size() <= self.infoType->size();

helper context ASD!Message def: superTypeOfEmptyMessage(): String =
	if ((self.subset = #req and thisModule.ConsElements->includes(self)) or
			(self.subset = #pro and thisModule.ProvElements->includes(self))) then
			'True'
	else
		'False'
	endif; 

-- COMPARING INFOTYPES --------------------------------------------------------

helper context ASD!InfoType def: isCompatible(aux: ASD!InfoType): String =
	if ((self.subset = aux.subset) and (self.valueRange = aux.valueRange)) then
		if (self.subset = #req and self.isSubtypeOf(aux)) or (self.subset = #pro and aux.isSubtypeOf(self)) then
			'True'
		else
			'False'
		endif
	else
		'Unknown'
	endif;

helper context ASD!InfoType def: isSubtypeOf(aux: ASD!InfoType): Boolean =
	(aux.infoType->size() <= self.infoType->size()) and
		(self.valueType.toString().isSubtypeOf(aux.valueType.toString()));

helper context ASD!InfoType def: superTypeOfEmptyInfoType(): String =
	if ((self.subset = #req and thisModule.ConsElements->includes(self)) or
			(self.subset = #pro and thisModule.ProvElements->includes(self))) then
			'True'
	else
		'False'
	endif; 

helper context ASD!EEnumValueType def: isSubtypeOf(aux: ASD!EEnumValueType): Boolean = true;

helper context String def: isSubtypeOf(aux: String): Boolean =
	(aux = 'document') or (aux = 'String' and not (self = 'document')) 
		or (aux = 'date' and not (self = 'date' or self = 'float')) or
			(aux = 'double' and (self = 'int' or self = 'float' or self = 'double')) or 
			(aux = 'float' and (self = 'int' or self = 'float')) or
			(aux = 'int' and self = 'int');

helper context ASD!InfoType def: isRelevant(): String = 
	if ((self.subset = #req and thisModule.ProvElements->includes(self)) or
			(self.subset = #pro and thisModule.ConsElements->includes(self))) then
			'NonRelevant'
	else
		'False'
	endif; 	

rule Service2Service {
	from
		s1 : ASD!ServiceDescription	in Prov	
	to
		s : ASD!ServiceDescription (
			name <- 'S1_' + s1.name -- , -- + ' - S2_' + s2.name
			-- infotypes <- s1.infotypes
		)
}

-- Maps Operation objects found in both source models
-- Indeed, it maps the operation from the Prov model
rule OperationInBoth2Operation {
	from
		o1 : ASD!Operation (not o1.getMatchingElementByName().oclIsUndefined() and
				thisModule.ProvElements->includes(o1)) 
				-- it doesn't matter where we find it: it is in both sets
	to
		o : ASD!Operation (
			name <- o1.name + 'Both',
			service <- o1.service,
			messagePattern <- o1.messagePattern,
			contents <- o1.contents
		),
		a : ASD!Annotation (
			owner <- o,
			key <- 'isCompatible', 
			value <- o1.isCompatible(o1.getMatchingElementByName())  	
		)
}

-- Maps Operatiion objects just found in one of the source models
rule OperationNonBoth2Operation {
	from
		o1 : ASD!Operation (o1.getMatchingElementByName().oclIsUndefined()) 
	to
		o : ASD!Operation (
			name <- o1.name + 'Non-Both',
			service <- thisModule.ServiceDescription,
			messagePattern <- o1.messagePattern,
			contents <- o1.contents
		),
		a : ASD!Annotation (
			owner <- o,
			key <- 'isCompatible', 
			value <- 'Unknown'  	
		),
		a2 : ASD!Annotation (
			owner <- o,
			key <- 'sourceModel', 
			value <- if(thisModule.ProvElements->includes(o1)) then
						'Prov'
					else
						'Cons'
					endif
		)
	
}

rule MessageInBoth2Message {
	from
		m1 : ASD!Message (not m1.getMatchingElementByName().oclIsUndefined() and
				thisModule.ProvElements->includes(m1))
				-- it doesn't matter where we find it: it is in both sets
	to
		m : ASD!Message (
			name <- m1.name,
			operation <- m1.operation,
			role <- m1.role,
			subset <- m1.subset,
			infoType <- m1.infoType
		),
		a : ASD!Annotation (
			owner <- m,
			key <- 'isCompatible', 
			value <- m1.isCompatible(m1.getMatchingElementByName())  	
		)
}

rule MessageNonBoth2Message {
	from
		m1 : ASD!Message (m1.getMatchingElementByName().oclIsUndefined()) 
	to
		m : ASD!Message (
			name <- m1.name,
			operation <- m1.operation,
			role <- m1.role,
			subset <- m1.subset,
			infoType <- m1.infoType
		),
		a : ASD!Annotation (
			owner <- m,
			key <- 'isCompatible', 
			value <- 'Unknown'  	
		),
		a2 : ASD!Annotation (
			owner <- m,
			key <- 'sourceModel', 
			value <- if(thisModule.ProvElements->includes(m1)) then
						'Prov'
					else
						'Cons'
					endif
		)
	
}


rule InfoTypeInBoth2InfoType {
	from
		it1 : ASD!InfoType (not it1.getMatchingElementByName().oclIsUndefined() and
				thisModule.ProvElements->includes(it1))
				-- it doesn't matter where we find it: it is in both sets
	to
		it : ASD!InfoType (
			name <- it1.name,
			message <- it1.message,
			infoType <- it1.infoType,
			valueType <- it1.valueType,
			valueRange <- it1.valueRange,
			service <- it1.service
		),
		a : ASD!Annotation (
			owner <- it,
			key <- 'isCompatible', 
			value <- it1.isCompatible(it1.getMatchingElementByName())  	
		)
}

rule InfoTypeNonBoth2InfoType {
	from
		it1 : ASD!InfoType (it1.getMatchingElementByName().oclIsUndefined()) 
	to
		it : ASD!InfoType (
			name <- it1.name,
			message <- it1.message,
			infoType <- it1.infoType,
			valueType <- it1.valueType,
			valueRange <- it1.valueRange,
			service <- it1.service
		),
		a : ASD!Annotation (
			owner <- it,
			key <- 'isCompatible', 
			value <- it1.isRelevant()  	
		),
		a2 : ASD!Annotation (
			owner <- it1,
			key <- 'sourceModel', 
			value <- if(thisModule.ProvElements->includes(it1)) then
						'Prov'
					else
						'Cons'
					endif
		)	
}

endpoint rule CheckCompatibility() {
	using
		{
			annotations : Sequence(ASD!Annotation) = ASD!Annotation.allInstancesFrom('Contract')->select(aux | aux.key = 'isCompatible');
			status : Boolean = true;
		}	
	to
		a : ASD!Annotation (
			owner <- thisModule.ServiceDescription	
		)
	do {
 		for (a in annotations) {
 			status <- status and (a.value = 'True' or a.value = 'NonRelevant');
 		}							 
 		a.key <- 'isCompatible';
 		a.value <- status.toString();
 	}
 }

-- key: toBeConsidered
-- value: unknownByInheritance
